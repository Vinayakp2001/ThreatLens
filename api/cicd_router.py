"""
CI/CD Integration Router

FastAPI router for CI/CD webhook endpoints and security gate validation APIs.
Provides secure webhook endpoints for automated security analysis triggers
and API endpoints for security gate validation in CI/CD pipelines.
"""
import logging
from typing import Dict, Any, Optional
from datetime import datetime

from fastapi import APIRouter, HTTPException, Request, Depends, BackgroundTasks, Header
from fastapi.security import HTTPAuthorizationCredentials
from pydantic import BaseModel

from api.cicd_integration import (
    CICDIntegrationService, WebhookPayload, PushWebhookPayload, 
    PullRequestWebhookPayload, SecurityGateCriteria, SecurityGateResult,
    SecurityReport, WebhookRegistration, WebhookConfig, WebhookEventType,
    security
)
from api.security_gate import SecurityGateValidator, SecurityGateType
from api.database import DatabaseManager
from api.wiki_storage import WikiStorage, wiki_storage
from api.monitoring import metrics_collector

logger = logging.getLogger(__name__)

# Create router
router = APIRouter(prefix="/api/v1/cicd", tags=["CI/CD Integration"])

# Dependency to get database manager
def get_db_manager() -> DatabaseManager:
    """Get database manager dependency"""
    # This would be injected from main app
    from api.main import get_db_manager as main_get_db
    return main_get_db()

# Dependency to get CI/CD integration service
def get_cicd_service(
    db: DatabaseManager = Depends(get_db_manager),
    wiki_storage: WikiStorage = Depends(lambda: wiki_storage)
) -> CICDIntegrationService:
    """Get CI/CD integration service dependency"""
    return CICDIntegrationService(db, wiki_storage)

# Dependency to get security gate validator
def get_security_gate_validator(
    db: DatabaseManager = Depends(get_db_manager),
    wiki_storage: WikiStorage = Depends(lambda: wiki_storage)
) -> SecurityGateValidator:
    """Get security gate validator dependency"""
    return SecurityGateValidator(db, wiki_storage)

# Request/Response Models
class RegisterWebhookRequest(BaseModel):
    """Request to register a new webhook"""
    url: str
    events: list[WebhookEventType]
    description: Optional[str] = None

class SecurityGateRequest(BaseModel):
    """Request for security gate validation"""
    repository_id: str
    criteria: SecurityGateCriteria
    deployment_environment: Optional[str] = "production"
    
class SecurityReportRequest(BaseModel):
    """Request for security report generation"""
    repository_id: str
    format: str = "json"  # json, pdf, html
    include_recommendations: bool = True

class SecurityGateApprovalRequest(BaseModel):
    """Request for security gate approval"""
    approver: str
    comments: Optional[str] = None

class SecurityGateRejectionRequest(BaseModel):
    """Request for security gate rejection"""
    rejector: str
    comments: Optional[str] = None

# Authentication dependency
async def verify_api_token(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Verify API token for CI/CD endpoints"""
    # In production, this would validate against stored API tokens
    # For now, we'll use a simple token validation
    if not credentials or not credentials.credentials:
        raise HTTPException(status_code=401, detail="Missing API token")
    
    # TODO: Implement proper token validation
    # This is a placeholder - in production you'd validate against a token store
    valid_tokens = ["cicd-token-placeholder"]  # This should come from config/database
    
    if credentials.credentials not in valid_tokens:
        raise HTTPException(status_code=401, detail="Invalid API token")
    
    return credentials.credentials

# Webhook Endpoints
@router.post("/webhooks/register", response_model=WebhookRegistration)
async def register_webhook(
    request: RegisterWebhookRequest,
    service: CICDIntegrationService = Depends(get_cicd_service),
    token: str = Depends(verify_api_token)
):
    """
    Register a new webhook endpoint for CI/CD integration
    
    Creates a secure webhook endpoint that can receive events from CI/CD systems
    like GitHub Actions, GitLab CI, Jenkins, etc.
    """
    try:
        config = WebhookConfig(
            url=request.url,
            secret="",  # Will be generated by service
            events=request.events,
            active=True
        )
        
        registration = await service.register_webhook(config)
        
        logger.info(f"Registered webhook for URL: {request.url}")
        
        return registration
        
    except Exception as e:
        logger.error(f"Failed to register webhook: {e}")
        raise HTTPException(status_code=500, detail=f"Webhook registration failed: {str(e)}")

@router.post("/webhooks/{webhook_id}")
async def receive_webhook(
    webhook_id: str,
    request: Request,
    background_tasks: BackgroundTasks,
    service: CICDIntegrationService = Depends(get_cicd_service),
    x_hub_signature_256: Optional[str] = Header(None),
    x_github_event: Optional[str] = Header(None)
):
    """
    Receive and process webhook events from CI/CD systems
    
    Supports various event types:
    - Push events: Trigger security analysis updates
    - Pull request events: Trigger PR security analysis  
    - Release events: Generate security reports
    - Deployment events: Validate security gates
    """
    try:
        # Get request body
        body = await request.body()
        payload_data = await request.json()
        
        # Determine event type
        event_type = WebhookEventType.PUSH  # Default
        if x_github_event:
            if x_github_event == "push":
                event_type = WebhookEventType.PUSH
            elif x_github_event == "pull_request":
                event_type = WebhookEventType.PULL_REQUEST
            elif x_github_event == "release":
                event_type = WebhookEventType.RELEASE
            elif x_github_event == "deployment":
                event_type = WebhookEventType.DEPLOYMENT
        
        # Create appropriate payload model
        if event_type == WebhookEventType.PUSH:
            payload = PushWebhookPayload(
                event_type=event_type,
                repository=payload_data.get('repository', {}),
                ref=payload_data.get('ref', ''),
                commits=payload_data.get('commits', []),
                head_commit=payload_data.get('head_commit'),
                sender=payload_data.get('sender')
            )
        elif event_type == WebhookEventType.PULL_REQUEST:
            payload = PullRequestWebhookPayload(
                event_type=event_type,
                repository=payload_data.get('repository', {}),
                action=payload_data.get('action', ''),
                number=payload_data.get('number', 0),
                pull_request=payload_data.get('pull_request', {}),
                sender=payload_data.get('sender')
            )
        else:
            payload = WebhookPayload(
                event_type=event_type,
                repository=payload_data.get('repository', {}),
                sender=payload_data.get('sender')
            )
        
        # Process webhook in background
        background_tasks.add_task(
            service.process_webhook_event,
            webhook_id,
            payload,
            x_hub_signature_256 or ""
        )
        
        return {
            "status": "accepted",
            "webhook_id": webhook_id,
            "event_type": event_type.value,
            "message": "Webhook event queued for processing"
        }
        
    except Exception as e:
        logger.error(f"Failed to process webhook {webhook_id}: {e}")
        raise HTTPException(status_code=500, detail=f"Webhook processing failed: {str(e)}")

# Security Gate Endpoints
@router.post("/security-gate/validate", response_model=SecurityGateResult)
async def validate_security_gate(
    request: SecurityGateRequest,
    service: CICDIntegrationService = Depends(get_cicd_service),
    token: str = Depends(verify_api_token)
):
    """
    Validate security gate criteria for deployment
    
    Checks repository security posture against defined criteria:
    - Maximum allowed security issues by severity
    - Minimum security score requirements
    - OWASP compliance requirements
    - Security regression detection
    """
    try:
        result = await service.validate_security_gate(
            request.criteria,
            request.repository_id
        )
        
        # Record metrics
        metrics_collector.record_security_gate_validation(
            repository_id=request.repository_id,
            status=result.status.value,
            security_score=result.security_score,
            environment=request.deployment_environment
        )
        
        logger.info(f"Security gate validation completed for {request.repository_id}: {result.status.value}")
        
        return result
        
    except Exception as e:
        logger.error(f"Security gate validation failed: {e}")
        raise HTTPException(status_code=500, detail=f"Security gate validation failed: {str(e)}")

@router.get("/security-gate/{gate_id}")
async def get_security_gate_result(
    gate_id: str,
    service: CICDIntegrationService = Depends(get_cicd_service),
    token: str = Depends(verify_api_token)
):
    """
    Get security gate validation result by ID
    
    Retrieves the results of a previous security gate validation,
    useful for checking status in CI/CD pipelines.
    """
    try:
        # This would retrieve stored gate result from database
        # For now, return a placeholder response
        return {
            "gate_id": gate_id,
            "status": "not_implemented",
            "message": "Gate result retrieval not yet implemented"
        }
        
    except Exception as e:
        logger.error(f"Failed to get security gate result: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to retrieve gate result: {str(e)}")

# Security Report Endpoints
@router.post("/reports/generate", response_model=SecurityReport)
async def generate_security_report(
    request: SecurityReportRequest,
    background_tasks: BackgroundTasks,
    service: CICDIntegrationService = Depends(get_cicd_service),
    token: str = Depends(verify_api_token)
):
    """
    Generate comprehensive security report for repository
    
    Creates detailed security analysis report including:
    - Security summary and metrics
    - Threat analysis and risk assessment
    - Mitigation coverage analysis
    - OWASP alignment and compliance
    - Security recommendations
    """
    try:
        report = await service.generate_security_report(
            request.repository_id,
            request.format
        )
        
        logger.info(f"Generated security report {report.report_id} for repository {request.repository_id}")
        
        return report
        
    except Exception as e:
        logger.error(f"Security report generation failed: {e}")
        raise HTTPException(status_code=500, detail=f"Report generation failed: {str(e)}")

@router.get("/reports/{report_id}")
async def get_security_report(
    report_id: str,
    service: CICDIntegrationService = Depends(get_cicd_service),
    token: str = Depends(verify_api_token)
):
    """
    Get security report by ID
    
    Retrieves a previously generated security report.
    """
    try:
        # This would retrieve stored report from database/storage
        # For now, return a placeholder response
        return {
            "report_id": report_id,
            "status": "not_implemented",
            "message": "Report retrieval not yet implemented"
        }
        
    except Exception as e:
        logger.error(f"Failed to get security report: {e}")
        raise HTTPException(status_code=500, detail=f"Failed to retrieve report: {str(e)}")

# Configuration and Status Endpoints
@router.get("/status")
async def get_cicd_integration_status(
    service: CICDIntegrationService = Depends(get_cicd_service),
    token: str = Depends(verify_api_token)
):
    """
    Get CI/CD integration system status
    
    Returns information about:
    - Active webhook configurations
    - Recent security gate validations
    - System health and performance metrics
    """
    try:
        return {
            "status": "healthy",
            "timestamp": datetime.now().isoformat(),
            "webhooks": {
                "active_count": len(service.webhook_configs),
                "supported_events": [event.value for event in WebhookEventType]
            },
            "security_gates": {
                "validation_enabled": True,
                "supported_criteria": [
                    "max_critical_issues",
                    "max_high_issues", 
                    "max_medium_issues",
                    "min_security_score",
                    "owasp_compliance",
                    "regression_detection"
                ]
            },
            "reports": {
                "generation_enabled": True,
                "supported_formats": ["json", "pdf", "html"]
            }
        }
        
    except Exception as e:
        logger.error(f"Failed to get CI/CD status: {e}")
        raise HTTPException(status_code=500, detail=f"Status check failed: {str(e)}")

@router.get("/webhooks")
async def list_webhooks(
    service: CICDIntegrationService = Depends(get_cicd_service),
    token: str = Depends(verify_api_token)
):
    """
    List all registered webhooks
    
    Returns information about all active webhook configurations.
    """
    try:
        webhooks = []
        for webhook_id, config in service.webhook_configs.items():
            webhooks.append({
                "webhook_id": webhook_id,
                "url": config.url,
                "events": [event.value for event in config.events],
                "active": config.active,
                "created_at": config.created_at.isoformat()
            })
        
        return {
            "webhooks": webhooks,
            "total_count": len(webhooks)
        }
        
    except Exception as e:
        logger.error(f"Failed to list webhooks: {e}")
        raise HTTPException(status_code=500, detail=f"Webhook listing failed: {str(e)}")

@router.delete("/webhooks/{webhook_id}")
async def delete_webhook(
    webhook_id: str,
    service: CICDIntegrationService = Depends(get_cicd_service),
    token: str = Depends(verify_api_token)
):
    """
    Delete a webhook configuration
    
    Removes a webhook endpoint and stops processing events for it.
    """
    try:
        if webhook_id in service.webhook_configs:
            del service.webhook_configs[webhook_id]
            # TODO: Also remove from database
            
            logger.info(f"Deleted webhook {webhook_id}")
            
            return {
                "status": "deleted",
                "webhook_id": webhook_id,
                "message": "Webhook configuration removed"
            }
        else:
            raise HTTPException(status_code=404, detail="Webhook not found")
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to delete webhook: {e}")
        raise HTTPException(status_code=500, detail=f"Webhook deletion failed: {str(e)}")

# Advanced Security Gate Management Endpoints
@router.post("/security-gate/validate-advanced")
async def validate_advanced_security_gate(
    repository_id: str,
    gate_type: SecurityGateType,
    policy_id: Optional[str] = None,
    validator: SecurityGateValidator = Depends(get_security_gate_validator),
    token: str = Depends(verify_api_token)
):
    """
    Advanced security gate validation with policy-based criteria
    
    Validates security gate using configurable policies that include:
    - Automated security regression detection
    - Policy-based approval workflows
    - Configurable security criteria
    - Expiry-based validation results
    """
    try:
        validation = await validator.validate_security_gate(
            repository_id=repository_id,
            gate_type=gate_type,
            policy_id=policy_id
        )
        
        logger.info(f"Advanced security gate validation completed for {repository_id}: {validation.status}")
        
        return validation
        
    except Exception as e:
        logger.error(f"Advanced security gate validation failed: {e}")
        raise HTTPException(status_code=500, detail=f"Advanced validation failed: {str(e)}")

@router.post("/security-gate/{validation_id}/approve")
async def approve_security_gate(
    validation_id: str,
    request: SecurityGateApprovalRequest,
    validator: SecurityGateValidator = Depends(get_security_gate_validator),
    token: str = Depends(verify_api_token)
):
    """
    Approve a security gate validation
    
    Manually approve a security gate that requires approval workflow.
    Used when automated validation fails but manual review determines
    the security posture is acceptable for deployment.
    """
    try:
        success = await validator.approve_security_gate(
            validation_id=validation_id,
            approver=request.approver,
            comments=request.comments
        )
        
        if success:
            logger.info(f"Security gate {validation_id} approved by {request.approver}")
            return {
                "status": "approved",
                "validation_id": validation_id,
                "approved_by": request.approver,
                "timestamp": datetime.now().isoformat(),
                "message": "Security gate approved successfully"
            }
        else:
            raise HTTPException(status_code=400, detail="Failed to approve security gate")
        
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Security gate approval failed: {e}")
        raise HTTPException(status_code=500, detail=f"Approval failed: {str(e)}")

@router.post("/security-gate/{validation_id}/reject")
async def reject_security_gate(
    validation_id: str,
    request: SecurityGateRejectionRequest,
    validator: SecurityGateValidator = Depends(get_security_gate_validator),
    token: str = Depends(verify_api_token)
):
    """
    Reject a security gate validation
    
    Manually reject a security gate validation, blocking deployment
    until security issues are addressed.
    """
    try:
        success = await validator.reject_security_gate(
            validation_id=validation_id,
            rejector=request.rejector,
            comments=request.comments
        )
        
        if success:
            logger.info(f"Security gate {validation_id} rejected by {request.rejector}")
            return {
                "status": "rejected",
                "validation_id": validation_id,
                "rejected_by": request.rejector,
                "timestamp": datetime.now().isoformat(),
                "message": "Security gate rejected"
            }
        else:
            raise HTTPException(status_code=400, detail="Failed to reject security gate")
        
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Security gate rejection failed: {e}")
        raise HTTPException(status_code=500, detail=f"Rejection failed: {str(e)}")

@router.get("/security-gate/{validation_id}/status")
async def get_security_gate_status(
    validation_id: str,
    validator: SecurityGateValidator = Depends(get_security_gate_validator),
    token: str = Depends(verify_api_token)
):
    """
    Get security gate validation status
    
    Retrieves the current status of a security gate validation,
    including approval status, expiry information, and detailed results.
    """
    try:
        validation = await validator.get_validation_status(validation_id)
        
        if not validation:
            raise HTTPException(status_code=404, detail="Validation not found")
        
        return validation
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Failed to get security gate status: {e}")
        raise HTTPException(status_code=500, detail=f"Status retrieval failed: {str(e)}")

@router.get("/security-gate/repository/{repository_id}/history")
async def get_repository_security_gate_history(
    repository_id: str,
    limit: int = 10,
    validator: SecurityGateValidator = Depends(get_security_gate_validator),
    token: str = Depends(verify_api_token)
):
    """
    Get security gate validation history for repository
    
    Returns historical security gate validations for a repository,
    useful for tracking security posture trends over time.
    """
    try:
        # This would retrieve validation history from database
        # For now, return a placeholder response
        return {
            "repository_id": repository_id,
            "validations": [],
            "total_count": 0,
            "message": "Security gate history retrieval not yet implemented"
        }
        
    except Exception as e:
        logger.error(f"Failed to get security gate history: {e}")
        raise HTTPException(status_code=500, detail=f"History retrieval failed: {str(e)}")